import { ConversionConfig } from '@/components/ConversionSettings';

export interface FaviconPackage {
  files: { name: string; blob: Blob; type: string }[];
  htmlCode: string;
  zipBlob?: Blob;
  filename: string;
}

// Ensure we always export images in the exact requested size
const renderToSizedBlob = (sourceCanvas: HTMLCanvasElement, size: number, type: 'image/png' | 'image/webp', quality?: number): Promise<Blob> => {
  const target = document.createElement('canvas');
  target.width = size;
  target.height = size;
  const ctx = target.getContext('2d');
  return new Promise((resolve, reject) => {
    try {
      if (!ctx) {
        reject(new Error('Failed to get 2D context'));
        return;
      }
      ctx.imageSmoothingEnabled = true;
      // @ts-ignore – not in lib.dom types across all TS versions
      ctx.imageSmoothingQuality = 'high';
      ctx.clearRect(0, 0, size, size);
      ctx.drawImage(
        sourceCanvas,
        0,
        0,
        sourceCanvas.width,
        sourceCanvas.height,
        0,
        0,
        size,
        size
      );
      target.toBlob((blob) => {
        if (blob) resolve(blob);
        else reject(new Error('Failed to create blob'));
      }, type, quality);
    } catch (e) {
      reject(e);
    }
  });
};

export const generateFaviconPackage = async (
  imageFile: File,
  icoBlob: Blob,
  resolutions: { size: number; canvas: HTMLCanvasElement }[],
  config: ConversionConfig
): Promise<FaviconPackage> => {
  const files: { name: string; blob: Blob; type: string }[] = [];
  const filename = config.filename || 'favicon';

  // Add ICO file
  files.push({ name: `${filename}.ico`, blob: icoBlob, type: 'image/x-icon' });

  // Generate and add PNG files
  if (config.includePNG || config.generateFaviconPackage) {
    // Quando pacote completo está ativo, sempre incluir (16,32,180,192,512)
    // e também honrar os tamanhos selecionados pelo usuário (evitar duplicatas)
    const base = config.generateFaviconPackage ? [16, 32, 180, 192, 512] : [];
    const pngSizes = Array.from(new Set([...base, ...config.selectedSizes])).sort((a, b) => a - b);

    for (const size of pngSizes) {
      const resolution = resolutions.find(r => r.size === size);
      const sourceCanvas = resolution ? resolution.canvas : resolutions[resolutions.length - 1].canvas; // Fallback to largest
      // Always render to exact requested size to avoid mislabeled dimensions and tiny outputs
      const pngBlob = await renderToSizedBlob(sourceCanvas, size, 'image/png');
      
      let pngFilename = `${filename}-${size}x${size}.png`;
      if (size === 180) pngFilename = 'apple-touch-icon.png';
      if (size === 192) pngFilename = `android-chrome-192x192.png`;
      if (size === 512) pngFilename = `android-chrome-512x512.png`;

      files.push({ name: pngFilename, blob: pngBlob, type: 'image/png' });
      if ((import.meta as any).env?.DEV) {
        try {
          // Log per-file for quick manual verification
          console.log(`[FaviconPackage] PNG ${pngFilename}: ${pngBlob.size} bytes`);
        } catch {}
      }
    }
  }

  // Generate and add WebP files
  if (config.includeWebP) {
    for (const { size, canvas } of resolutions) {
      if (config.selectedSizes.includes(size)) {
        const webpBlob = await renderToSizedBlob(canvas, size, 'image/webp', config.quality);
        files.push({ name: `${filename}-${size}x${size}.webp`, blob: webpBlob, type: 'image/webp' });
      }
    }
  }

  // Generate HTML code
  const htmlCode = generateHTMLCode(filename);

  // Create ZIP file
  const { default: JSZip } = await import('jszip');
  const zip = new JSZip();
  files.forEach(file => {
    zip.file(file.name, file.blob);
  });

  // Add default site.webmanifest and safari-pinned-tab.svg
  const manifestJson = {
    id: '/',
    name: 'IcoSmith',
    short_name: 'IcoSmith',
    description: 'Icons and favicon manifest generated by IcoSmith',
    start_url: '/',
    scope: '/',
    display: 'standalone',
    theme_color: '#0A0F1E',
    background_color: '#0A0F1E',
    icons: [
      { src: '/android-chrome-192x192.png', sizes: '192x192', type: 'image/png', purpose: 'any maskable' },
      { src: '/android-chrome-512x512.png', sizes: '512x512', type: 'image/png', purpose: 'any maskable' }
    ]
  };
  zip.file('site.webmanifest', JSON.stringify(manifestJson, null, 2));
  zip.file('safari-pinned-tab.svg', '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64"><path fill="#000" d="M20 4h24a16 16 0 0 1 16 16v24a16 16 0 0 1-16 16H20A16 16 0 0 1 4 44V20A16 16 0 0 1 20 4Z"/></svg>');
  const zipBlob = await zip.generateAsync({ type: 'blob' });

  if ((import.meta as any).env?.DEV) {
    try {
      console.log('[FaviconPackage] Files included:');
      for (const f of files) console.log(` - ${f.name}: ${f.blob.size} bytes`);
      console.log(`[FaviconPackage] ZIP size: ${zipBlob.size} bytes`);
    } catch {}
  }

  return { files, htmlCode, zipBlob, filename };
};

const generateHTMLCode = (filename: string): string => {
  const lines = [
    `<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">`,
    `<link rel="icon" href="/favicon.ico" sizes="any">`,
    `<link rel="icon" type="image/png" sizes="32x32" href="/${filename}-32x32.png">`,
    `<link rel="icon" type="image/png" sizes="16x16" href="/${filename}-16x16.png">`,
    `<link rel="manifest" href="/site.webmanifest">`,
    `<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#0f172a">`,
    `<meta name="theme-color" content="#0A0F1E">`
  ];
  return lines.join('\n');
};

