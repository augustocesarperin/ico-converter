import { ConversionConfig } from '@/components/ConversionSettings';

export interface FaviconPackage {
  files: { name: string; blob: Blob; type: string }[];
  htmlCode: string;
  zipBlob?: Blob;
  windowsZipBlob?: Blob;
  filename: string;
  pwaName?: string;
  pwaThemeColor?: string;
  pwaBackgroundColor?: string;
  pwaMaskIconColor?: string;
}

// Renders a new blob resizing the provided canvas to the target square size
// Keeps high-quality resampling and supports PNG/WebP outputs
async function renderToSizedBlob(
  sourceCanvas: HTMLCanvasElement,
  size: number,
  mimeType: 'image/png' | 'image/webp',
  quality?: number,
): Promise<Blob> {
  const target = document.createElement('canvas');
  target.width = size;
  target.height = size;
  const ctx = target.getContext('2d');
  if (!ctx) throw new Error('2D context not available');
  ctx.imageSmoothingEnabled = true;
  (ctx as unknown as CanvasRenderingContext2D & { imageSmoothingQuality?: ImageSmoothingQuality }).imageSmoothingQuality = 'high';
  ctx.clearRect(0, 0, size, size);
  ctx.drawImage(
    sourceCanvas,
    0,
    0,
    sourceCanvas.width,
    sourceCanvas.height,
    0,
    0,
    size,
    size,
  );

  // Prefer toBlob; fallback to dataURL if needed
  const blob = await new Promise<Blob>((resolve) => {
    target.toBlob((b) => {
      if (b) return resolve(b);
      // Fallback: dataURL -> Blob
      const dataUrl = target.toDataURL(mimeType, quality);
      fetch(dataUrl)
        .then((r) => r.blob())
        .then((bb) => resolve(bb));
    }, mimeType, quality);
  });
  return blob;
}

// Render keeping aspect ratio inside WxH (letterbox) with transparency
async function renderToBoxBlob(
  sourceCanvas: HTMLCanvasElement,
  width: number,
  height: number,
  mimeType: 'image/png',
): Promise<Blob> {
  const target = document.createElement('canvas');
  target.width = width;
  target.height = height;
  const ctx = target.getContext('2d');
  if (!ctx) throw new Error('2D context not available');
  ctx.clearRect(0, 0, width, height);
  const iw = sourceCanvas.width;
  const ih = sourceCanvas.height;
  const scale = Math.min(width / iw, height / ih);
  const w = Math.max(1, Math.round(iw * scale));
  const h = Math.max(1, Math.round(ih * scale));
  const dx = Math.floor((width - w) / 2);
  const dy = Math.floor((height - h) / 2);
  ctx.imageSmoothingEnabled = true;
  (ctx as unknown as CanvasRenderingContext2D & { imageSmoothingQuality?: ImageSmoothingQuality }).imageSmoothingQuality = 'high';
  ctx.drawImage(sourceCanvas, 0, 0, iw, ih, dx, dy, w, h);
  const blob = await new Promise<Blob>((resolve) => {
    target.toBlob((b) => resolve(b!), mimeType);
  });
  return blob;
}

export const generateFaviconPackage = async (
  imageFile: File,
  icoBlob: Blob,
  resolutions: { size: number; canvas: HTMLCanvasElement }[],
  config: ConversionConfig
): Promise<FaviconPackage> => {
  const files: { name: string; blob: Blob; type: string }[] = [];
  const filename = config.filename || 'favicon';

  // Add ICO file
  files.push({ name: `${filename}.ico`, blob: icoBlob, type: 'image/x-icon' });

  // Generate and add PNG files
  if (config.includePNG || config.generateFaviconPackage) {
    const base = config.generateFaviconPackage ? [16, 32, 180, 192, 512] : [];
    const pngSizes = Array.from(new Set([...base, ...config.selectedSizes])).sort((a, b) => a - b);

    for (const size of pngSizes) {
      const resolution = resolutions.find(r => r.size === size);
      const sourceCanvas = resolution ? resolution.canvas : resolutions[resolutions.length - 1].canvas;
      const pngBlob = await renderToSizedBlob(sourceCanvas, size, 'image/png');
      
      let pngFilename = `${filename}-${size}x${size}.png`;
      if (size === 180) pngFilename = 'apple-touch-icon.png';
      if (size === 192) pngFilename = `android-chrome-192x192.png`;
      if (size === 512) pngFilename = `android-chrome-512x512.png`;

      files.push({ name: pngFilename, blob: pngBlob, type: 'image/png' });
      if ((import.meta as unknown as { env?: Record<string, unknown> }).env?.DEV) {
        try {
          console.log(`[FaviconPackage] PNG ${pngFilename}: ${pngBlob.size} bytes`);
        } catch {
          /* noop */
        }
      }
    }
  }


  if (config.includeWebP) {
    for (const { size, canvas } of resolutions) {
      if (config.selectedSizes.includes(size)) {
        const webpBlob = await renderToSizedBlob(canvas, size, 'image/webp', config.quality);
        files.push({ name: `${filename}-${size}x${size}.webp`, blob: webpBlob, type: 'image/webp' });
      }
    }
  }

  const htmlCode = generateHTMLCode(filename, config);


  const { default: JSZip } = await import('jszip');
  const zip = new JSZip();
  files.forEach(file => {
    zip.file(file.name, file.blob);
  });


  const manifestJson = {
    id: '/',
    name: config.pwaName || 'IcoSmith',
    short_name: config.pwaName || 'IcoSmith',
    description: 'Icons and favicon manifest generated by IcoSmith',
    start_url: '/',
    scope: '/',
    display: 'standalone',
    theme_color: config.pwaThemeColor || '#0A0F1E',
    background_color: config.pwaBackgroundColor || '#0A0F1E',
    icons: [
      { src: '/android-chrome-192x192.png', sizes: '192x192', type: 'image/png', purpose: 'any maskable' },
      { src: '/android-chrome-512x512.png', sizes: '512x512', type: 'image/png', purpose: 'any maskable' }
    ]
  };
  zip.file('site.webmanifest', JSON.stringify(manifestJson, null, 2));
  zip.file('safari-pinned-tab.svg', '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64"><path fill="#000" d="M20 4h24a16 16 0 0 1 16 16v24a16 16 0 0 1-16 16H20A16 16 0 0 1 4 44V20A16 16 0 0 1 20 4Z"/></svg>');
  const zipBlob = await zip.generateAsync({ type: 'blob' });

  // Windows assets package (optional)
  let windowsZipBlob: Blob | undefined;
  if (config.windowsAssets) {
    const wzip = new JSZip();
    const prefixTaskbar = config.windowsOrganizeZip ? 'Assets/Taskbar/' : '';
    const prefixTiles = config.windowsOrganizeZip ? 'Assets/Tiles/' : '';
    const prefixStore = config.windowsOrganizeZip ? 'Assets/StoreLogo/' : '';
    const prefixRoot = config.windowsOrganizeZip ? 'Assets/' : '';

    const getCanvas = (size: number) => {
      return (
        resolutions.find(r => r.size === size)?.canvas ||
        resolutions[resolutions.length - 1].canvas
      );
    };

    // Prefer the most suitable source for a given target when High Fidelity is enabled
    const getBestSourceCanvas = (targetSize: number): HTMLCanvasElement => {
      if (!config.windowsHighFidelity) return getCanvas(targetSize);
      // exact match
      const exact = resolutions.find(r => r.size === targetSize)?.canvas;
      if (exact) return exact;
      // choose the closest larger; otherwise the largest available
      const larger = [...resolutions]
        .map(r => r.size)
        .filter(s => s >= targetSize)
        .sort((a, b) => a - b)[0];
      if (larger) {
        return (resolutions.find(r => r.size === larger) as { canvas: HTMLCanvasElement }).canvas;
      }
      return resolutions[resolutions.length - 1].canvas;
    };

    // 44x44 base
    const base44 = getCanvas(44);
    const targetSizes = [16,20,24,30,32,40,48];
    for (const s of targetSizes) {
      const blob = await renderToSizedBlob(base44, s, 'image/png');
      wzip.file(`${prefixTaskbar}${filename}-44x44.targetsize-${s}.png`, blob);
    }
    // Optional 256 variant; with High Fidelity prefer a 256 source (or closest larger)
    const baseFor256 = getBestSourceCanvas(256);
    const blobTs256 = await renderToSizedBlob(baseFor256, 256, 'image/png');
    wzip.file(`${prefixTaskbar}${filename}-44x44.targetsize-256.png`, blobTs256);

    // Unplated / lightunplated variants: 20/24/32
    for (const s of [20,24,32]) {
      const b = await renderToSizedBlob(base44, s, 'image/png');
      wzip.file(`${prefixTaskbar}${filename}-44x44.targetsize-${s}_altform-unplated.png`, b);
      wzip.file(`${prefixTaskbar}${filename}-44x44.targetsize-${s}_altform-lightunplated.png`, b);
    }

    // Square256 (plated/unplated) â€” prefer high-fidelity source when enabled
    const base256 = getBestSourceCanvas(256);
    const sq256 = await renderToSizedBlob(base256, 256, 'image/png');
    const sq256u = await renderToSizedBlob(base256, 256, 'image/png');
    wzip.file(`${prefixTiles}${filename}-Square256x256.png`, sq256);
    wzip.file(`${prefixTiles}${filename}-Square256x256_unplated.png`, sq256u);

    // Tiles for Store (profiles)
    const profile = config.windowsProfile || 'recommended';
    const addSquare150 = async () => {
      for (const scale of [100,125,150,200,400] as const) {
        const size = Math.round(150 * (scale / 100));
        const src = getBestSourceCanvas(150);
        const b = await renderToSizedBlob(src, size, 'image/png');
        wzip.file(`${prefixTiles}Square150x150Logo.scale-${scale}.png`, b);
      }
      if (config.windowsCanonicalNames) {
        const src = getBestSourceCanvas(150);
        const b = await renderToSizedBlob(src, 150, 'image/png');
        wzip.file(`${prefixRoot}Square150x150Logo.png`, b);
      }
    };
    const addSquare310 = async () => {
      for (const scale of [100,125,150,200,400] as const) {
        const size = Math.round(310 * (scale / 100));
        const src = getBestSourceCanvas(310);
        const b = await renderToSizedBlob(src, size, 'image/png');
        wzip.file(`${prefixTiles}Square310x310Logo.scale-${scale}.png`, b);
      }
      if (config.windowsCanonicalNames) {
        const src = getBestSourceCanvas(310);
        const b = await renderToSizedBlob(src, 310, 'image/png');
        wzip.file(`${prefixRoot}Square310x310Logo.png`, b);
      }
    };
    const addWide310x150 = async () => {
      for (const scale of [100,125,150,200,400] as const) {
        const w = Math.round(310 * (scale / 100));
        const h = Math.round(150 * (scale / 100));
        const src = getBestSourceCanvas(Math.max(w, h));
        const b = await renderToBoxBlob(src, w, h, 'image/png');
        wzip.file(`${prefixTiles}Wide310x150Logo.scale-${scale}.png`, b);
      }
      if (config.windowsCanonicalNames) {
        const src = getBestSourceCanvas(310);
        const b = await renderToBoxBlob(src, 310, 150, 'image/png');
        wzip.file(`${prefixRoot}Wide310x150Logo.png`, b);
      }
    };

    if (profile === 'minimal') {
      await addSquare150();
    } else if (profile === 'recommended') {
      await addSquare150();
      // StoreLogo set
      const storeScales = [100,125,150,200,400] as const;
      const storeBase = getBestSourceCanvas(64);
      for (const scale of storeScales) {
        const size = Math.round(50 * (scale / 100));
        const b = await renderToSizedBlob(storeBase, size, 'image/png');
        wzip.file(`${prefixStore}StoreLogo.scale-${scale}.png`, b);
      }
      if (config.windowsCanonicalNames) {
        const b = await renderToSizedBlob(storeBase, 50, 'image/png');
        wzip.file(`${prefixRoot}StoreLogo.png`, b);
      }
    } else {
      // complete
      await addSquare150();
      await addWide310x150();
      await addSquare310();
      const storeScales = [100,125,150,200,400] as const;
      const storeBase = getBestSourceCanvas(64);
      for (const scale of storeScales) {
        const size = Math.round(50 * (scale / 100));
        const b = await renderToSizedBlob(storeBase, size, 'image/png');
        wzip.file(`${prefixStore}StoreLogo.scale-${scale}.png`, b);
      }
      if (config.windowsCanonicalNames) {
        const b = await renderToSizedBlob(storeBase, 50, 'image/png');
        wzip.file(`${prefixRoot}StoreLogo.png`, b);
      }
    }

    // base 44 as canonical if requested
    if (config.windowsCanonicalNames) {
      const b44 = await renderToSizedBlob(base44, 44, 'image/png');
      wzip.file(`${prefixRoot}Square44x44Logo.png`, b44);
    }

    windowsZipBlob = await wzip.generateAsync({ type: 'blob' });
  }

  return { 
    files, 
    htmlCode, 
    zipBlob, 
    windowsZipBlob, 
    filename,
    pwaName: config.pwaName,
    pwaThemeColor: config.pwaThemeColor,
    pwaBackgroundColor: config.pwaBackgroundColor,
    pwaMaskIconColor: config.pwaMaskIconColor,
  };
};

const generateHTMLCode = (filename: string, config?: ConversionConfig): string => {
  const lines = [
    `<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">`,
    `<link rel="icon" href="/favicon.ico" sizes="any">`,
    `<link rel="icon" type="image/png" sizes="32x32" href="/${filename}-32x32.png">`,
    `<link rel="icon" type="image/png" sizes="16x16" href="/${filename}-16x16.png">`,
    `<link rel="manifest" href="/site.webmanifest">`,
    `<link rel="mask-icon" href="/safari-pinned-tab.svg" color="${config?.pwaMaskIconColor || '#0f172a'}">`,
    `<meta name="theme-color" content="${config?.pwaThemeColor || '#0A0F1E'}">`,
    `<meta name="application-name" content="${config?.pwaName || 'IcoSmith'}">`,
    `<meta name="apple-mobile-web-app-title" content="${config?.pwaName || 'IcoSmith'}">`
  ];
  return lines.join('\n');
};

